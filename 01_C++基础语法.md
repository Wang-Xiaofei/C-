---
UID: 2310101052
link: 
cssclasses: 
tags:
  - C加/基础语法
关联文件: "[[../../02C语言/230825C语言|230825C语言]]"
---
## 1 C++的面向对象的三大特性

1. 封装：将相同属性的数据和方法封装在一起，加权限区分用户只能借助公共方法操作私有数据。
2. 继承：体现在类和类之间的关系，如果A类继承于B类，那么A类直接拥有B类的数据和方法。
3. 多态：一个接口（函数），拥有多种功能。




## 2 命名空间

为了解决合作开发时的**命名冲突问题**， C++ 引入了**命名空间（ Namespace）** 的概念

**定义**
namespace 是 C++中的关键字，用来定义一个命名空间，语法格式为：  

```c++
namespace name{  
//variables, functions, classes  
}
```

name 是命名空间的名字，它里面可以包含变量、函数、类、 typedef、  `#define` 等，最后由{ }包围。

- **特点**：
	- 1. 命名空间可以嵌套
	- 2. 可以随时将新的成员加入命名空间
	- 3. 命名空间中函数的声明与实现可以分离
	- 4. 无名命名空间只能在当前源文件使用
	- 5. 命名空间取别名
	- 6. 函数重载命名空间的所有同名函数都被申明可用
	- 7. 使用 using 申明命名空间中的某几个成员可用
	- 8. using 申明整个命名空间，可以直接通过成员名使用

```cpp
//1. 命名空间可以嵌套
namespace A{
	//定义变量、函数、类型等
	int data = 20;
	namespace B{
		inr data = 10;
	}
}

//命名空间中函数的声明与实现可以分离
namespace MySpace{
	void func1();
	void func2(int param);
}

void MySpace::func1(){
	cout <"MySpace::func1"<<endl;
}
void MySpace::func2(int param){
	cout <"MySpace::func2 "<param <endl;
}

//命名空间取别名
namespace veryLongName{
	int a = 100;
	int b = 200;
}
//给veryLongName.取别名
namespace shortName = veryLongName;

//声明的两种方式
namespace C{
	int a = 10;
	int b = 20;
	int c = 30;
}
void teste3()
{
//方式7：申明命名空间中的某几个成员
using C::a;
using C::b;
using C::c;
//方式8：使用整个命名空间
using namespace C;
cout<<"a ="<<a<<endl;
cout<<"b "<<b<<endl;
cout<<"c="<<c<<endl;
}

```


**使用方法**：
1. 使用域解析操作符 `==` ，`==` 是一个新符号，**解决归属性的问题**。在 C++中用来指明要使用的命名空间。
2. 采用 using 关键字声明；using 声明不仅可以**针对命名空间中的一个变量**，也可以用于**声明整个命名空间**。

```cpp
/*************定义******************/
namespace Li{//小李的变量定义
FILE fp -NULL;
}
namespace Han{//小韩的变量定义
FILE fp=NULL
}
/**************使用*****************/
//方法一
Li:fp=fopen(”one.txt”,”r);//使用小李定义的变量fp
Han::fp = fopen("two.txt", "rb+"); //使用小韩定义的变量 fp

//方法二
using Li::fp;  
fp = fopen("one.txt", "r"); //使用小李定义的变量 fp  
Han :: fp = fopen("two.txt", "rb+"); //使用小韩定义的变量 fp

/***************方法二的另外用法*****************/
//声明命名空间
using namespace Li;  
fp = fopen("one.txt", "r"); //使用小李定义的变量 fp 
Han::fp = fopen("two.txt", "rb+"); //使用小韩定义的变量 fp

```

如果命名空间 Li 中还定义了其他的变量，那么同样具有 fp 变量的效果。在 using 声明后，如果有未具体指定命名空间的变量产生了命名冲突，那么默认采用命名空间 Li 中的变量。


## 3 头文件


```ad-def
title: C++ 头文件
总结的 C++ 头文件的现状：  
1) 旧的 C++ 头文件，如 iostream.h、 fstream.h 等将会继续被支持，尽管它们不在官方标准中。这些头文件的内容不在命名空间 std 中。  
2) 新的 C++ 头文件，如 iostream、 fstream 等包含的基本功能和对应的旧版头文件相似，但头文件的内容在命名空间 std 中。  
注意：在标准化的过程中，库中有些部分的细节被修改了，所以旧的头文件和新的头文件不一定完全对应。  
3) 标准 C 头文件如 stdio.h、 stdlib.h 等继续被支持。头文件的内容不在 std 中。  
4) 具有 C 库功能的新 C++头文件具有如 cstdio、 cstdlib 这样的名字。它们提供的内容和相应的旧的 C 头文件相同，只是内容在 std 中。
```

可以发现，对于不带.h 的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std；对于带.h 的头文件，没有使用任何命名空间，所有符号都位于全局作用域。这也是 C++ 标准所规定的。

1) 使用命名空间 std：  

```cpp
[[include]] <cstdio>  
int main(){  
std::printf("http://c.biancheng.net\n");  
return 0;  
} 
```
 
2) 不使用命名空间 std：  

```cpp
[[include]] <cstdio>  
int main(){  
printf("http://c.biancheng.net\n");  
return 0;  
}
```
两种写法都可以，正常编译。**建议第一种写法**。

**规范**
- [ ] 使用命名空间 std
- [ ] 尽量使用这些 C++ 新增的头文件，例如 iostream、 fstream、 string 等
- [ ] 推荐在函数内部声明 std

例如：

```cpp
[[include〈iostream]]>
[[include]] <string>
int main(){
	//声明命名空间std
	using namespace std;
	/定义字符串变量
	string str;
	/定义int变量
	int age;
	/从控制台获取用户输入
	cin>>str>>age;
	//将数据输出到控制台
	cout〈<str<<"已经成立"<<age<<"年了！"〈<endl;
	return 0;
}

```

## 4 C++输入输出（ cin 和 cout）

iostream 是 Input Output Stream 的缩写，意思是“输入输出流”。

**cout 和 cin 都是 C++ 的内置对象，而不是关键字**。cout 和 cin 就分别是 ostream 和 istream 类的对象，使用 cout 进行输出时需要紧跟`<<`运算符，使用 cin 进行输入时需要紧跟`>>`运算符，这两个运算符可以自行分  
析所处理的数据类型，因此无需像使用 scanf 和 printf 那样给出格式控制字符串。


```cpp
cout<<"Please input a float number:"<<endl;
//两者等价
cout<<"Please input an int number:\n";
```

endl 最后一个字符是字母“l”，而非阿拉伯数字“1”，它是“end of line”的缩写。其中 endl 表示 换行，与 C 语言里的`\n` 作用相同。当然这段代码中也可以用`\n` 来替代 endl，这样就得写作：




## 5 C++中的 const 更像编译阶段的\#define

- C 和 C++对 const 的处理方式的差异
	- C 语言对 const 的处理和普通变量一样，会到内存中读取数据； C++ 对 const 的处理更像是编译时期的`#define` ，是一个值替换的过程。
	- C 语言中的 const 变量在多文件编程时的表现和普通变量一样，除了**不能修改**，没有其他区别。C++ 对 const 的特性做了调整， C++ 规定，全局 const 变量的作用域仍然是当前文件，但是**它在其他文件中是不可见的**，这和添加了 static 关键字的效果类似。
	- 由于 C++ 中全局 const 变量的可见范围仅限于当前源文件，所以可以将它放在头文件中，这样即使头文件被包含多次也不会出错
- **总结**：
	- C 和 C++中全局 const 变量的作用域相同，都是当前文件，不同的是它们的可见范围： C 语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而 C++中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。
	- C++ 中的 const 变量虽然也会占用内存，也能使用`&`获取得它的地址，但是在使用时却更像编译时期的 `#define` ；`#define` 也是值替换，**可见范围也仅限于当前文件**。

Const 在结构体函数的形参和实参的用法：
定义函数时，形参与实参的传递方式分为两种：1、值传递 2、地址传递
1. 值传递：
	- 形参数据的改变不会影响实参。赋值时，相当于实参数据拷贝一份给形参；
	- 当数据较大时，这种传递方式占用内存空间，此时，建议采用地址传递；配合 const 使用
2. 地址传递：
	- 形参数据的改变会影响实参的值。
	- 若想形参数据的不影响实参的值，可使用 const；加入 const 之后，一旦有修改形参的操作就会报错，可以防止我们的误操作。


###### 1、c++与 c 中的 const 都是修饰变量为只读变量

###### 2、c 语言严格准许 const 修饰的是只读变量。
只读变量通过变量名不能直接赋值。可以通过指针赋值


###### 3、c++的 const 会对变量优化
1. 如果以**常量**初始化 const 修饰的变量，编译器会将变量的值放入符号常量表中，不会立即给变量开辟空间。
![[01_C++基础语法.md_Attachments/01_C++基础语法-2.png|600]]

2. 只有当对 a **取地址**时，编译器才会给开辟空间
![[01_C++基础语法.md_Attachments/01_C++基础语法-1.png]]

3. 如果以**变量**初始化只读变量时，编译器立即开辟空间

4. 如果以 const 修饰的是**自定义类型**的变量也不会有符号常量表，立即开辟空间

5. c++尽量用 const 代替 define


```cpp
[[define]] A 10
const int A=10;
```

- const 有类型，可进行编译器类型安全检查。 `#define` 无类型，不可进行类型检查
- const有作用域，而 `#define`不重视作用域 ，宏不能作为命名空间、结构体、类的成员，而 const 可以

## 6 C++引用

引用是 c++对 c 的重要扩充。在 c/c++中指针的作用基本都是一样的，但是 c++增加了另外一种给函数传递地址的途径，这就是按引用传递(pass-by-reference),它也存在于其他一些编程语言中，并不是 c++的发明。

变量名实质上是一段连续内存空间的别名，是一个标号（门牌号）程序中通过变量来申请并命名内存空间通过变量的名字可以使用存储空间。

对一段连续的内存空间只能取一个别名吗？c+中新增了**引用**的概念，引用可以作为一个已定义变量的别名。基本语法：`Type&ref=val`则注意事项：&在此不是求地址运算，而是起标识作用。类型标识符是指目标变量的类型必须在声明引用变量时进行初始化。引用初始化之后不能改变。不能有ULL引用。必须确保引用是和一块合法的存储单元关联。可以建立对数组的引用。

### 6.1 引用的定义

- 引用的本质：就是给变量**取别名**。
- 引用定义的步骤：
	1. &别名
	2. 给那个变量取别名
	3. 从上到下整体替换
案例 1：给普通变量取别名
![[01_C++基础语法.md_Attachments/01_C++基础语法-3.png]]

案例 2：给数组取别名
![[01_C++基础语法.md_Attachments/01_C++基础语法-4.png]]
![[01_C++基础语法.md_Attachments/01_C++基础语法-5.png]]

案例三：给指针变量取别名
![[01_C++基础语法.md_Attachments/01_C++基础语法-6.png]]

案例四：给函数取别名
![[01_C++基础语法.md_Attachments/01_C++基础语法-7.png]]

### 6.2 引用作为函数的参数

1. 函数内部可以通过**引用**操作外部变量。

![[01_C++基础语法.md_Attachments/01_C++基础语法-8.png]]

2. 节约空间
![[01_C++基础语法.md_Attachments/01_C++基础语法-9.png]]


### 6.3 引用作为函数的返回值类型（链式操作）

![[01_C++基础语法.md_Attachments/01_C++基础语法-10.png]]

### 6.4 常引用

给常量取别名
![[01_C++基础语法.md_Attachments/01_C++基础语法-11.png]]
不能通过常引用修改内容
**常引用**作为函数的参数：防止函数内部修改外部的值。

![[01_C++基础语法.md_Attachments/01_C++基础语法-12.png]]

### 6.5 引用的本质：常量指针

浅显的理解，
```c
int a = 10;
int &b = a; //b为a的别名  int * const b = &a;
b = 180;    //a的值为100  *b = 100;
```



## 7 C++ new 和 delete 运算符简介

在 C 语言中，动态分配内存用 `malloc()` 函数，释放内存用 `free()` 函数。

在 C++中，这两个函数仍然可以使用，但是 C++又新增了两个关键字， `new` 和 `delete`： new 用来动态分配内  
存， delete 用来释放内存。

|     |  动态分配内存     |   释放内存   |
|:----:|:----:|:----:|
|C|`malloc()`|`free()`|
|C++|`new`|`delete`|

```c++
/****************C 中动态分配内存***************************/
int *p = (int*) malloc( sizeof(int) * 10 ); //分配 10 个 int 型的内存空间  
free(p); //释放内存

/******************C ++中动态分配内存***********************/
int *p = new int; //分配 1 个 int 型的内存空间  
delete p; //释放内存

//分配一组连续的数据，可以使用 new[]
int *p = new int[10]; //分配 10 个 int 型的内存空间  
delete[] p;

```
用 `new[]` 分配的内存需要用 `delete[]` 释放，它们是一一对应的。和 `malloc()` 一样， `new` 也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。为了避免内存泄露，**通常 `new` 和 `delete`、 `new[]` 和 `delete[]` 操作符应该成对出现**，**并且不要和 C 语言中`malloc()`、 `free()` 一起混用**。在 C++中，建议使用 `new` 和 `delete` 来管理内存，它们可以使用 C++的一些新特性，最明显的是可以自动调用构造函数和析构函数


## 8 C++ inline 内联函数详解

为了消除函数调用的时空开销， C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于 C 语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（ Inline Function） ，又称内嵌函数或者内置函数。

使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，**一般只将那些短小的、频繁调用的函数声明为内联函数**。

> **注意**，建议==不要在函数声明处添加 inline，要在函数定义处添加 inline 关键字==，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。

发生函数调用时，编译器会先对实参进行计算，再将计算的结果传递给形参，并且函数执行完毕后会得到一个值，而不是得到一个表达式，这和简单的字符串替换相比省去了很多麻烦，所以**在编写 C++代码时我推荐使用内联函数来替换带参数的宏**。

**和宏一样，内联函数可以定义在头文件中（不用加 static 关键字），并且头文件被多次 `#include` 后也不会引发重复定义错误**。 这一点和非内联函数不同，非内联函数是禁止定义在头文件中的，它所在的头文件被多次`#include` 后会引发重复定义错误。

内联函数在编译时会将函数调用处用函数体替换，编译完成后函数就不存在了，所以在链接时不会引发重复定义错误。这一点和宏很像，宏在预处理时被展开，编译时就不存在了。从这个角度讲，**内联函数更像是编译期间的宏**。

> **内联由编译器决定**。内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。

- **内联函数主要有两个作用**，
	- 一是消除函数调用时的开销，
	- 二是取代带参数的宏

- **规范地使用 C++内联函数**
	- 严格地说，**内联函数不应该有声明，应该将函数定义放在本应该出现函数声明的地方**，这是一种良好的编程风格。  
	- 在多文件编程中，我们通常将函数的定义放在源文件中，将函数的声明放在头文件中，希望调用函数时，引入对应的头文件即可，我们鼓励这种将函数定义和函数声明分开的做法。但**这种做法不适用于内联函数，将内联函数的声明和定义分散到不同的文件中会出错**。
	- **在多文件编程时，我建议将内联函数的定义直接放在头文件中，并且禁用内联函数的声明**。
	- 不能存在任何形式的循环语句
	- 不能存在过多的条件判断语句
	- 函数体不能过于庞大
	- 不能对函数取地址

- **函数和内联函数的区别**
	- 函数是一段可以重复使用的代码，它位于虚拟地址空间中的代码区，也占用可执行文件的体积，而内联函数的代码在编译后就被消除了，不存在于虚拟地址空间中，没法重复使用。

- **宏函数和内联函数的区别**
	- 相同点：
		- 宏函数和内联函数都会在适当的位置进行展开避免函数调用开销。
	- 不同点：
		- 宏函数的参数没有类型，不能保证参数的完整性。
		- 内联函数的参数有类型能保证参数的完整性。
		- 宏函数在预处理阶段展开
		- 内联函数在编译阶段展开
		- 宏函数没有作用域的限制，不能作为命名空间、结构体、类的成员
		- 内联函数有作用域的限制。能作为命名空间、结构体、类的成员

## 9 C++函数的默认参数详解

所谓默认参数，指的是当函数调用中省略了实参时自动使用的一个值，这个值就是给形参指定的默认值。

**C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。** 实参和形参的传值是从左到右依次匹配的，默认参数的连续性是保证正确传参的前提。

在 C 语言中，int fun ()表示返回值为 int,接受任意参数的函数，int fun(void) 表示返回值为 int 的无参函数。**在 C++中，int fun ()和 int fun(void)具有相同的意义，都表示返回值为 int 的无参函数**。

```c++
//下面的写法是正确的：  
void func(int a, int b=10, int c=20){ }  
void func(int a, int b, int c=20){ }  
//但这样写不可以：  
void func(int a, int b=10, int c=20, int d){ }  
void func(int a, int b=10, int c, int d=20){ }
```
### 9.1 到底在声明中还是定义中指定默认参数

- 注意
	- 在声明处和定义处位于不同的作用域时，可以同时指定默认参数，
	- 在声明处和定义处位于相同的作用域时，只能在声明处或者在定义处指定默认参数
	- （C /C++ 语言有四种作用域，分别是函数原型作用域、局部作用域（函数作用域）、块作用域、文件作用域（全局作用域）。）
	- 需要注意，在给定的作用域中一个形参只能被赋予一次默认参数。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认值，而且该形参右侧的所有形参必须都有默认值。
- 原因：**因为 C++ 规定，在给定的作用域中只能指定一次默认参数**。

## 10 C++函数重载详解

**C++ 允许多个函数拥有相同的名字，只要它们的参数列表不同就可以**，这就是函数的重载（ Function Overloading） 。借助重载，一个函数名可以有多种用途.

> 参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同，仅仅参数名称不同是不可以的。函数返回值也不能作为重载的依据。

- 函数的重载的规则：  
	- 函数名称必须相同。  
	- 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。  
	- 函数的返回类型可以相同也可以不相同。  
	- 仅仅返回类型不同不足以成为函数的重载。

重载就是在一个作用范围内（同一个类、同一个命名空间等）有多个名称相同但参数不同的函数。重载的结果是让一个函数名拥有了多种用途，使得命名更加方便（在中大型项目中，给变量、函数、类起名字是一件让人苦恼的问题），调用更加灵活。

### 10.1 C++ 是如何做到函数重载的

C++代码**在编译时会根据参数列表对函数进行重命名**，当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做**重载决议（ Overload Resolution）** 。

- void Swap(int a, int b)会被重命名为 `_Swap_int_int`， 
- void Swap(float x, float y)会被重命名为 `_Swap_float_float`。

- **注意**
	- [2] 函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

![[01_C++基础语法.md_Attachments/01_C++基础语法.png]]

C++ 标准还规定，编译器应该按照从高到低的顺序来搜索重载函数，首先是精确匹配，然后是类型提升，最后才是类型转换；一旦在某个优先级中找到唯一的一个重载函数就匹配成功，不再继续往下搜索。

如果在一个优先级中找到多个（两个以及以上）合适的重载函数，编译器就会陷入两难境地，不知道如何抉择，编译器会将这种模棱两可的函数调用视为一种错误，因为这些合适的重载函数同等“优秀”，没有一个脱颖而出，调用谁都一样。这就是函数重载过程中的**二义性错误**。


```ad-def
title: 类型提升和类型转换
color:255, 99, 72
注意，类型提升和类型转换不是一码事！类型提升是积极的，是为了更加高效地利用计算机硬件，不会导致数据丢失或精度降低；而类型转换是不得已而为之，不能保证数据的正确性，也不能保证应有的精度。类型提升只有上表中列出的几种情况，其他情况都是类型转换。
```


### 10.2 多个参数时的二义性

当重载函数有多个参数时也会产生二义性，而且情况更加复杂。 C++ 标准规定，如果有且只有一个函数满足下列条件，则匹配成功：  
1. 该函数对每个实参的匹配都不劣于其他函数；  
2. 至少有一个实参的匹配优于其他函数。

![[01_C++基础语法.md_Attachments/01_C++基础语法-13.png]]
在设计重载函数时，**参数类型过少或者过多都容易引起二义性错误**，因为这些类型相近，彼此之间会相互转换。


## 11 如何实现 C++和 C 的混合编程？

- C++和 C 的混合编程复杂的原因：
	- **C++ 支持函数的重载**，是因为 C++ 会在程序的编译阶段对函数的函数名进行“再次重命名”。
	- **C 语言是不支持函数重载**的，它不会在编译阶段对函数的名称做较大的改动。
	- 使用 C 和 C++ 进行混合编程时，考虑到**对函数名的处理方式不同**，势必会造成编译器在程序链接阶段无法找到函数具体的实现，导致**链接失败**。
- 解决方案：
	- 使用 `extern "C"`，可以轻松解决 C++ 和 C 在处理代码方式上的差异性。
	- extern "C" 大致有 2 种用法，
		- 当仅修饰一句 C++ 代码时，直接将其添加到该函数代码的开头即可；
		- 用于修饰一段 C++ 代码，只需为 extern "C" 添加一对大括号{}，并将要修饰的代码囊括到括号内即可。




## 12 指针

- 注意：
	- 指针与函数：
		- 值传递不改变实参的值；地址传递能改变实参的值。



### 12.1 指针、数组、函数

案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序
例如数组：int arr[10]={4,3,6,9,1,2,10,8,7,5}:


```c++
[[include]] <iostream>
using namespace std;

//冒泡排序函数
void bubbleSort(int* arr,int len)
{
	for (int i = 0; i < len - 1; i++)
	{
		for (int j = 0; j < len - i - 1; j++)
		{
			//如果j>j+1的值I交换数字
			if (arr[j] > arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j+1];
				arr[j + 1] = temp;
			}
		}
	}
}
//打印数组
void printArray(int *arr,int len) {
	for (int i = 0; i < len; i++) {
		cout << "排列好的数组：" << arr[i] << endl;
	}
}
int main() {
	//1、创建数组
	int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };

	//计算数组长度
	int len = sizeof(arr) / sizeof(arr[0]);
	//2、创建函数，实现冒泡
	bubbleSort(arr, len);

	//3、打印排序好的数组
	printArray(arr,len);

	system("pause");

	return 0;
}
```


## 13 相比于 C, C++的特点

### 13.1 更严格的类型转换



### 13.2 结构体类型增强

- c++中结构体的使用时可以不用写 struct
- C++结构体中可以封装函数（关键）
```
struct stu
{
	int num;
	char name[32];
};
void test()
{
	//c++可以不写struct，C必须写
	stu Liming = {100,"Liming"};
	cout<<"num="<<Liming.num<<"name = "<<Liming.name<<endl;
}

```


### 13.3 c++新增 bool 类型

标准 c++的 bool 类型有两种内建的常量 true(转换为整数1)和 false(转换为整数0)表示状态。这三个名字都是关键字。bool 类型只有两个值，true(1值)，false(0值)bool 类型占1个字节大小给 bool 类型赋值时，非0值会自动转换为 true(1)值会自动转换 false(0) 

```C++
void test()
{ 
	cout<<sizeof(false)<<endl;//为1，//booL 类型占一个字节大小
	boolflag=true;//c 语高中没有这种类 
	flag=100;//给 booL 类型赋值时，非0值会自动转换为true(1)，0值会自动转换 false(0)
}
```

c 语言中也有 bool 类型，在 c99标准之前是没有 bool 关键字，c99标准已经有 bool 类型，包含头文件 stdbool.h, 就可以使用和 c++一样的 bool 类型。

#### 13.3.1 三目运算符增强


```c++
void test04()
{
	int a=10;
	int b =20;
	//c++三目运算符 返回值是引用,c语言返回的是值
	a>b?a:b=100;
	cout<<"a="<<a<<""<<"b="<b<<endl;
}
//结果
//c++
a=10 b=100
//c中
20
```


