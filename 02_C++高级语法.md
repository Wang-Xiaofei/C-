---
UID: 2310122047
link: ""
cssclasses: 
tags:
  - C加/高级语法
---
## 1 类和对象

### 1.1 基础知识
- 注意（**书写规范**）
	- 类名的首字母一般大写
	- 在类定义的最后有一个分号 `;`，它是类定义的一部分，表示类定义结束了，不能省略。
	- 类只是一个模板（ Template），编译后不占用内存空间，所以**在定义类时不能对成员变量进行初始化**，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。
	- 当成员函数定义**在类外时**，就必须在函数名前面加上类名予以限定。 `::` 被称为域解析符（也称作用域运算符或作用域限定符） ，用来连接类名和函数名，指明当前函数属于哪个类
	- 建议在**类体内部**对成员函数作**声明**，而在**类体外部**进行**定义**，这是一种良好的编程习惯
	- **成员变量大都以 `m_` 开头**，这是约定成俗的写法，不是语法规定的内容。以 `m_` 开头既可以一眼看出这是成员变量，又可以和成员函数中的形参名字区分开。
	- 根据 C++软件设计规范，实际项目开发中的**成员变量以及只在类内部使用的成员函数（只被成员函数调用的成员函数）都建议声明为 private，而只将允许通过对象调用的成员函数声明为 public**。
	- 给成员变量赋值的函数通常称为 **set 函数**，它们的名字通常以 set 开头，后跟成员变量的名字；
	- 读取成员变量的值的函数通常称为 **get 函数**，它们的名字通常以 get 开头，后跟成员变量的名字。
	- 在一个类体中， private 和 public 可以分别出现多次。每个部分的有效范围到出现另一个访问限定符或类体结束时（最后一个右花括号）为止。但是为了使程序清晰，应该养成这样的习惯，**使每一种成员访问限定符在类定义体中只出现一次**。
	- 建议“将数据设置成私有，将方法设置成共有。”

#### 1.1.1 C++ 类访问修饰符
类将数据和方法封装在一起，加以权限区分，用户只能通过公共方法访问私有数据。 

数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。关键字 public、private、protected 称为访问修饰符。

一个类可以有多个 public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的默认访问修饰符是 private。

类的权限分为：private、protected、public。但是在类的内部不存在权限之分。只是对类外有效。如果类不涉及到继承，private、protected没有区别，都是私有属性。

**继承中的特点**
有 public, protected, private 三种继承方式，它们相应地改变了基类成员的访问属性。
1. **public 继承：** 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private
2. **protected 继承：** 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private
3. **private 继承：** 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private

但无论哪种继承方式，下面两点都没有改变：
- 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；
- 2.protected 成员可以被派生类访问。

**总结一下三种继承方式：**

|继承方式|基类的public成员|基类的protected成员|基类的private成员|继承引起的访问控制关系变化概括|
|---|---|---|---|---|
|public继承|仍为public成员|仍为protected成员|不可见|基类的非私有成员在子类的访问属性不变|
|protected继承|变为protected成员|变为protected成员|不可见|基类的非私有成员都为子类的保护成员|
|private继承|变为private成员|变为private成员|不可见|基类中的非私有成员都称为子类的私有成员|


练习 1
![[02_C++高级语法.md_Attachments/02_C++高级语法-1.png]]

```cpp
[[include]] <iostream>
[[include]] <string.h>
using namespace std;
class Person{
private:
    char mName[32];
    int mAge;
public:
    //初始化成员
    void initPerson(char *name, int age)
    {
        strcpy(mName, name);
        if(age>=0 && age <=100)
        {
            mAge = age;
        }
        else
        {
            cout<<"年龄无效"<<endl;
        }
    };
    //设置名字
    void setmName(char *name)
    {
        strcpy(mName, name);
    };
    //设置年领
    void setmAge(int age)
    {
        if(age>=0 && age <=100)
        {
            mAge = age;
        }
        else
        {
            cout<<"年龄无效"<<endl;
        }
    };
    //获得名字
    char* getmName(void)
    {
        return mName;
    };
    //获得年龄
    int getAge(void)
    {
        return mAge;
    };
    //显示所有数据
    void showPerson(void)
    {
        cout<<mName<<" "<<mAge<<endl;
    };
};
void test04()
{
    Person ob1;
    ob1.initPerson("Ling", 30);
    ob1.showPerson();
    ob1.setmName("Mane");
    ob1.setmAge(20);
    cout<<"年龄="<<ob1.getAge()<<endl;
    ob1.showPerson();
};
int main()
{
    cout << "Hello World!" << endl;
    test04();
    return 0;
}
```

练习 2：
![[02_C++高级语法.md_Attachments/02_C++高级语法.png]]

```cpp
[[include]] <iostream>

using namespace std;

class Cude
{
private:
    int mLength;
    int mWidth;
    int mHeight;
public:
    //初始化
    void init(int Length, int Width, int Height)
    {
        mLength = Length;
        mWidth = Width;
        mHeight = Height;
    };
    //设置长度
    void setmLength(int Length)
    {
        mLength = Length;
    };
    //得到长度
    int getLength(void)
    {
        return mLength;
    };
    //设置宽度
    void setWidth(int Width)
    {
        mWidth = Width;
    };
    //得到宽度
    int getWidth(void)
    {
        return mWidth;
    };
    //设置高度
    void setHeight(int Height)
    {
        mHeight = Height;
    };
    //得到高度
    int getHeight(void)
    {
        return mHeight;
    };

    //计算立方体的体积
    int cudeVolume(void)
    {
        return (mLength * mWidth * mHeight);
    };

    //计算立方体的面积
    int cudeArea(void)
    {
        int area = 0;
        area = 2*((mLength*mWidth)+(mLength*mHeight)+(mWidth*mHeight));
        return area;
    };

    //成员函数实现比较两种长方体是否相等
    bool compareCude(Cude &ob)
    {
        if(cudeVolume() == ob.cudeVolume())
            cout<<"相等"<<endl;
        else
            cout<<"不相等"<<endl;
    };
};


//全局函数实现比较两种长方体是否相等
bool compareCude(Cude &ob1, Cude &ob2)
{
    if(ob1.getLength() == ob2.getLength(), ob1.getWidth() == ob2.getWidth(), ob1.getHeight() == ob2.getHeight())
    {
        cout<<"相等"<<endl;
        return true;
    }
    else
    {
        cout<<"不相等"<<endl;
        return false;
    }
};

void test1(void)
{
    Cude ob1, ob2;
    ob1.init(10, 20, 30);
    ob2.init(10, 20, 30);
    cout<<"成员函数：立方体的面积="<<ob1.cudeArea()<<"  "<<"立方体的体积="<<ob1.cudeVolume()<<endl;
    ob1.compareCude(ob2);

    compareCude(ob1, ob2);
};

int main()
{
    cout << "Hello World!" << endl;

    test1();
    return 0;
}

```

案例三：

![[02_C++高级语法.md_Attachments/02_C++高级语法-2.png]]
```cpp
[[include]] <iostream>

using namespace std;

class Point
{
private:
    int mX;
    int mY;
public:
    //初始化
    void init(int x, int y)
    {
        mX = x;
        mY = y;
    };
    //设置X
    void setX(int x)
    {
        mX = x;
    };
    //得到X
    int getX(void)
    {
        return mX;
    };
    //设置Y
    void setY(int y)
    {
        mY = y;
    };
    //得到Y
    int getY(void)
    {
        return mY;
    };

};

class Circle
{
private:
    Point cir_point; //圆心
    int mR;
public:
    void setPoint(int x, int y)
    {
        cir_point.setX(x);
        cir_point.setY(y);
    };
    Point getPoint(void)
    {
        return cir_point;
    };
    void setR(int r)
    {
        mR = r;
    };
    int getR(void)
    {
        return mR;
    };

    int pointPosition(Point &ob)
    {
        int L = 0;
        L = ((ob.getX()-cir_point.getX())*(ob.getX()-cir_point.getX()))+((ob.getY()-cir_point.getY())*(ob.getY()-cir_point.getY())); //易错点
        if(L > (mR*mR))
            return 1;
        else if(L == (mR*mR))
            return 0;
        else if(L < (mR*mR))
            return -1;
    };
};

void test02()
{
    Point p1;
    p1.setX(3);
    p1.setY(4);

    Circle c;
    c.setPoint(1,1);
    c.setR(5);

    if(c.pointPosition(p1) == 1)
        cout<<"在圆外"<<endl;
    else if(c.pointPosition(p1) == 0)
        cout<<"在圆上"<<endl;
    else if(c.pointPosition(p1) == -1)
        cout<<"在圆内"<<endl;

};


int main()
{
    cout << "Hello World!" << endl;
    test02();
    return 0;
}

```


### 1.2 new 和 delete 堆区空间操作
#### 1.2.1 new 和 delete 操作基础类型的空间

new 和 delete： new 用来动态分配内存， delete 用来释放内存。
```cpp
/******************C ++中动态分配内存***********************/
int *p = new int; //分配 1 个 int 型的内存空间  
delete p; //释放内存

//分配一组连续的数据，可以使用 new[]
int *p = new int[10]; //分配 10 个 int 型的内存空间  
delete [] p;//如果此处不加[],表示释放的是数组首地址的空间。
```
用 new[] 分配的内存需要用 delete[] 释放，它们是一一对应的。
**注意**：如果在 nw 表达式中使用[ ],必须在相应的 delete 表达式中也使用[ ] 。如果在 new 表达式中不使用 [ ],一定不要在相应的 delete 表达式中使用[ ].
#### 1.2.2 new和delete操作类的空间

[new 申请对象空间]
```cpp
Student *pStu = new Student;
```

pStu 是一个指针，它指向 Student 类型的数据，在栈上创建出来的对象都有一个名字，比如 stu，使用指针指向它不是必须的。但是**通过 new 创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针**，否则以后再也无法找到这个对象了，更没有办法使用它。 也就是说，**使用 new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数**。

**栈内存是程序自动管理的**，不能使用 delete 删除在栈上创建的对象；**堆内存由程序员管理**，对象使用完毕后可以通过 delete 删除。在实际开发中， new 和 delete 往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。

**栈（ Stack）** 和**堆（ Heap）** 是 C/C++ 程序员必须要了解的两个概念

例子：

```cpp
[[include]] <iostream>
using namespace std;

class Student{
public:
	char *name;
	int age;
	float score;
	
	void say(){
	cout<<name〈<"的年龄是"〈<age〈<"，成绩是"<<score〈<end1;
	}
};

int main(){
	Student *pStu = new Student;
	pStu->name = "小明”；
	pStu->age = 15;
	pStu->score = 92.5f;
	pStu->say();
	delete pStu;//删除对象
	
	return 0;
}
```

- 总结：
	- 两种创建对象的方式：
		- 一种是**在栈上创建**，形式和定义普通变量类似；
		- 一种是**在堆上使用 new 关键字创建**，必须要用一个指针指向它，要记得 delete 掉不再使用的对象。
	- 通过对象名字访问成员使用点号.，通过对象指针访问成员使用箭头->，这和结构体非常类似。

[new 申请对象数组]
![[02_C++高级语法.md_Attachments/02_C++高级语法-10.png]]


## 2 C++构造函数详解

### 2.1 构造函数的定义与调用
在 C++中，有一种特殊的成员函数，它的名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。这种特殊的成员函数就是**构造函数（ Constructor）** 。

类实例化对象的时候系统自动调用构造函数完成对象的初始化
如果用户不提供构造函数编译器会自动添加一个默认的构造函数（空函数）

```cpp
[[include]] <iostream>  
using namespace std;  
 
class Student{  
private:  
	char *m_name;  
	int m_age;  
	float m_score;  
public:  
	//声明构造函数  
	Student(char *name, int age, float score);  
	//声明普通成员函数  
	void show();  
};  
 
//定义构造函数  
Student::Student(char *name, int age, float score){  
	m_name = name;  
	m_age = age;  
	m_score = score;  
}  
//定义普通成员函数  
void Student::show(){  
	cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;  
}  
 
int main(){  
	//在栈上创建对象时向构造函数传参  
	Student stu("小明", 15, 92.5f);  //隐式构造（推荐）
	Student ob1 = stu("小明", 15, 92.5f);  //显式构造
	stu.show();  
	//在堆上创建对象时向构造函数传参  
	Student *pstu = new Student("李华", 16, 96);  
	pstu -> show();  

	//构造函数隐式转换（类中只有一个数据成员）（理解）
	
	return 0;  
}

```
该例在 Student 类中定义了一个构造函数 `Student(char *, int, float)`，它的作用是给三个 private 属性的成员变量赋值。要想调用该构造函数，就得在创建对象的同时传递实参，并且实参由( )包围，和普通的函数调用非常类似。
- **构造函数必须是 public 属性的**
- **构造函数没有返回值**
- 不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许；  
- 函数体中不能有 return 语句。

> 📌**构造函数隐式转换**（类中只有一个数据成员）

```cpp
//构造函数隐式转换（类中只有一个数据成员）
A ob1=100;
```

**explicits 关键字**：防止构造函数隐式转换
- explicit 修饰<u>构造函数</u>

```cpp
//防止有参构造隐式转换
explicit A(int a)
{
	mA = a;
	cout<<"A的有参构造mA="<<mA<<end1;
}
//允许有参构造隐式转换
A(int a)
{
	mA = a;
	cout<<"A的有参构造mA="<<mA<<end1;
}
```

> **有关构造函数的调用时机**

如果用户不提供任何构造函数编译器默认提供一个空的无参构造。
如果用户定义了构造函数（不管是有参、无参），编译器不再提供默认构造函数。

> [!col5] 先实例化，还是先调用构造函数？
> 先给对象开空间（实例化）然后调用构造函数（初始化）



### 2.2 析构函数

类的**析构函数**是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。

析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

先调用析构函数，再释放对象的空间。

> [!note] 一般情况下，空的析构函数就足够。但是**如果一个类有指针成员，这个类必须写析构函数，释放指针成员所指向空间**。


> [!note] 📌**析构函数的执行时机**🌟🌟🌟🌟
析构函数在对象被销毁时调用，而对象的销毁时机与它所在的内存区域有关。
> - 在所有函数之外创建的对象是全局对象，它和全局变量类似，位于内存分区中的**全局数据区**，程序在结束执行时会调用这些对象的析构函数。
> - 在函数内部创建的对象是局部对象，它和局部变量类似，位于**栈区**，函数执行结束时会调用这些对象的析构函数。
> - new 创建的对象位于**堆区**，通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。



### 2.3 拷贝构造函数

#### 2.3.1 拷贝构造函数定义
拷贝构造：本质是构造函数；
拷贝构造：**旧对象**初始化   **新对象**才会被调用。

**拷贝构造函数**是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象。
    
- 复制对象把它作为参数传递给函数。
    
- 复制对象，并从函数返回这个对象。
    

- 拷贝构造和无参构造有参构造的关系
	- 如果用户定义了拷贝构造或者有参构造都会屏蔽无参构造。
	- 如果用户定义了无参构造或者有参构造不会屏蔽拷贝杓造。

[[C++知识点/C++类对象的赋值与复制介绍（二）|C++类对象的赋值与复制介绍（二）]]
#### 2.3.2 拷贝构造函数调用
拷贝构造的几种调用方式
1.**旧对象给新对象初始化,调用拷贝构造**
```cpp
Data ob1(10);
Data ob2 = ob1;
```

2.**给对象取别名不会调用拷贝构造**
```cpp
Data ob1(10);
Data &ob2 = ob1;
```

3.**普通对象作为函数参数调用函数时，会发生拷贝构造**
![[02_C++高级语法.md_Attachments/02_C++高级语法-3.png]]

4.函数返回值普通对象  (**Visual Studio 会发生拷贝构造**)(Qtcreater,linux 不会发生[优化])
- 讲解视频[10\_拷贝构造函数调用的几种形式\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1UT4y1R7Yv?p=37&vd_source=3172f3a7fe748de0a36d42f0844ca1c3)
**Visual Studio 会发生拷贝构造**
```cpp
/*************Visual Studio 会发生拷贝构*****************/
Data4 getobject (void)
{
	Data4 ob1(10);
	return obl;  //teturn返回值存放到栈区的临时区域的匿名对象上，此时，发生了拷贝构造
}
void test04()
{
	Data4 ob2 getobject () //此处，并没有发生拷贝构造
}
int main(int argc, char* argc[])
{
	test04();
	return 0;
}
//结果
有参构造 mA = 10
拷贝构造函数
析构函数 mA = 10
析构函数 mA = 10

```

![[02_C++高级语法.md_Attachments/02_C++高级语法-16.png]]


**Qtcreater,linux 不会发生拷贝构造**
```cpp
/*************Qtcreater,linux 不会发生拷贝构造*******************/
Data4 getobject (void)
{
	Data4 ob1(10);
	return obl;
}
void test04()
{
	Data4 ob2 getobject ()
}
//结果
有参构造 mA = 10
析构函数 mA = 10
```

![[02_C++高级语法.md_Attachments/02_C++高级语法-17.png]]


如果在类中没有定义拷贝构造函数，编译器会自行定义一个。**如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数**。拷贝构造函数的最常见形式如下：


```cpp
classname (const classname &obj) {
   // 构造函数的主体
}
```

实例：

```cpp
[[include]] <iostream>
 
using namespace std;
 
class Line
{
   public:
      int getLength( void );
      Line( int len );             // 简单的构造函数
      Line( const Line &obj);      // 拷贝构造函数
      ~Line();                     // 析构函数
 
   private:
      int *ptr;
};
 
// 成员函数定义，包括构造函数
Line::Line(int len)
{
    cout << "调用构造函数" << endl;
    // 为指针分配内存
    ptr = new int;
    *ptr = len;
}
 
Line::Line(const Line &obj)
{
    cout << "调用拷贝构造函数并为指针 ptr 分配内存" << endl;
    ptr = new int;
    *ptr = *obj.ptr; // 拷贝值
}
 
Line::~Line(void)
{
    cout << "释放内存" << endl;
    delete ptr;
}
int Line::getLength( void )
{
    return *ptr;
}
 
void display(Line obj)
{
   cout << "line 大小 : " << obj.getLength() <<endl;
}
 
// 程序的主函数
int main( )
{
   Line line1(10);
 
   Line line2 = line1; // 这里也调用了拷贝构造函数
 
   display(line1);
   display(line2);
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
调用构造函数
调用拷贝构造函数并为指针 ptr 分配内存
调用拷贝构造函数并为指针 ptr 分配内存
line 大小 : 10
释放内存
调用拷贝构造函数并为指针 ptr 分配内存
line 大小 : 10
释放内存
释放内存
释放内存
```

### 2.4 深拷贝与浅拷贝

**条件**：
默认的拷贝构造为**浅拷贝**
如果类中**没有指针成员**，不用实现**拷贝构造**和**析构函数**。
如果类中**有指针成员**，必须实现**析构函数**释放指针成员指向的堆栈空间，必须实现**拷贝构造**完成拷贝动作。

**两个的区别**：
- 在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的--复制。当数据成员中没有指针时，浅拷贝是可行的，但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，从而导致指针悬挂现象，所以，此时，必须采用深拷贝。
- 深拷贝和浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来存储数据，从而也就解决了指针悬挂的问题。`当数据成员中有指针时，必须要用深拷贝。`

示例代码如下：

```cpp
[[include]] <iostream>
using namespace std;

// 深浅拷贝操作

class Person
{
public:
    // 无参构造函数
    Person()
    {
        cout << "Person的构造函数调用" << endl;
    }
    // 有参构造函数
    Person(int a, int h)
    {
        m_Age = a;
        m_Height = new int(h);
        cout << "Person的有参构造函数调用" << endl;
    }
    // 析构造函数
    ~Person()
    {
        // 将堆区开辟的空间释放掉
        if(m_Height != NULL)
        {
            delete m_Height;
            m_Height = NULL;    // 防止野指针出现
        }
        cout << "Person的析构造函数调用" << endl;
    }

    // 自己实现拷贝构造函数，解决浅拷贝带来的问题
    Person(const Person &p)
    {
        cout << "Person拷贝造函数调用" << endl;
        m_Age = p.m_Age;
        // m_Height = p.m_Height;   // 编译器默认实现就是这行代码(浅拷贝)
        // 深拷贝操作
        m_Height = new int(*p.m_Height);
    }

    int m_Age;  // 年龄
    int *m_Height; // 身高
};

void test01()
{
    Person p1(18, 160);
    cout << "Person的年龄：" << p1.m_Age << "身高为：" << *p1.m_Height << endl;

    Person p2(p1);  // 执行来浅拷贝操作（调用默认的拷贝函数）
    cout << "P2的年龄：" << p1.m_Age << "身高为：" << *p2.m_Height << endl;
}

int main(int argc, char const *argv[])
{
    /* code */
    test01();

    return 0;
}
```

运行结果：

```
Person的有参构造函数调用
Person的年龄：18身高为：160
Person拷贝造函数调用
P2的年龄：18身高为：160
Person的析构造函数调用
Person的析构造函数调用
```



- 浅拷贝内存示例图
![[02_C++高级语法.md_Attachments/02_C++高级语法-7.png]]

- 深拷贝内存示例图

![[02_C++高级语法.md_Attachments/02_C++高级语法-8.png]]


### 2.5 构造函数的重载

和普通成员函数一样，构造函数是允许重载的。一个类可以有多个重载的构造函数，创建对象时根据传递的实参来判断调用哪一个构造函数。

构造函数的调用是强制性的，**一旦在类中定义了构造函数，那么创建对象时就一定要调用**，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。


```cpp
[[include]] <iostream>  
using namespace std;  
 
class Student{  
private:  
	char *m_name;  
	int m_age;  
	float m_score;  
public: 
	//两种构造函数
	Student();  
	Student(char *name, int age, float score);  
	void setname(char *name);  
	void setage(int age);  
	void setscore(float score);  
	void show();  
};  
 
Student::Student(){  
	m_name = NULL;  
	m_age = 0;  
	m_score = 0.0;  
}  
Student::Student(char *name, int age, float score){  
	m_name = name;  
	m_age = age;  
	m_score = score;  
}  
void Student::setname(char *name){  
	m_name = name;  
}  
void Student::setage(int age){  
	m_age = age;  
}  
void Student::setscore(float score){  
	m_score = score;  
}  
void Student::show(){  
	if(m_name == NULL || m_age <= 0){  
		cout<<"成员变量还未初始化"<<endl;  
	}else{  
		cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;  
	}  
}  
 
int main(){  
	//调用构造函数 Student(char *, int, float)  
	Student stu("小明", 15, 92.5f);  
	stu.show();  
	 
	//调用构造函数 Student()  
	Student *pstu = new Student();  
	pstu -> show();  
	pstu -> setname("李华");  
	pstu -> setage(16);  
	pstu -> setscore(96);  
	pstu -> show();  
	 
	return 0;  
}

```

构造函数 `Student(char *, int, float)` 为各个成员变量赋值，构造函数 `Student()` 将各个成员变量的值设置为空，它们是重载关系。根据Student()创建对象时不会赋予成员变量有效值，所以还要调用成员函数 setname()、setage()、 setscore() 来给它们重新赋值。


## 3 初始化列表（重要）

一个类的对象作为另一个类的成员：**成员对象**。
如果类中想调用**成员对象**的**有参**构造，必须使用初始化列表。

![[02_C++高级语法.md_Attachments/02_C++高级语法-9.png]]

类会**自动调用**成员对象的**无参**构造。
类想调用成员对象**有参构造**，必须使用初始化列表。

---
构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。例如：

```cpp
class CExample {
public:
    int a;
    float b;
    //构造函数初始化列表
    CExample(): a(0),b(8.8)
    {
    }
    //构造函数内部赋值
    CExample()
    {
        a=0;
        b=8.8;
    }
};
```

上面的例子中两个构造函数的结果是一样的。上面的构造函数（使用初始化列表的构造函数）显式的初始化类的成员；而没使用初始化列表的构造函数是对类的成员赋值，并没有进行显式的初始化。

****<font color="#0070c0">使用初始化列表的原因</font>
- 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。<u>初始化和赋值</u>对**内置类型的成员**没有什么大的区别，像上面的任一个构造函数都可以。
- 对**非内置类型成员变量**，为了避免两次构造，推荐使用类构造函数初始化列表。但有的时候必须用带有初始化列表的构造函数：
	1. **成员类型是没有默认构造函数的类**。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。
	2. **const 成员或引用类型的成员**。因为 const 对象或引用类型只能初始化，不能对他们赋值。
	3. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
	4. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
	5. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化

**初始化数据成员与对数据成员赋值的含义是什么？有什么区别**？
- 首先把数据成员按类型分类并分情况说明:
	1. **内置数据类型，复合类型（指针，引用）**。- 在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的
	2. **用户定义类型（类类型）**。- 结果上相同，但是性能上存在很大的差别。因为类类型的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行构造对象的工作，调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器提供的默认按成员赋值行为）

**注意点**：
初始化列表的成员初始化顺序: C++ 初始化类成员时，**是按照声明的顺序初始化的**，而不是按照出现在初始化列表中的顺序。

```cpp
class CMyClass {
    CMyClass(int x, int y);
    int m_x;
    int m_y;
};

CMyClass::CMyClass(int x, int y) : m_y(y), m_x(m_y)
{
};
```

你可能以为上面的代码将会首先做 m_y=I，然后做 m_x=m_y，最后它们有相同的值。但是编译器先初始化 m_x，然后是 m_y,，因为它们是按这样的顺序声明的。结果是 m_x 将有一个不可预测的值。有两种方法避免它，一个是总是按照你希望它们被初始化的顺序声明成员，第二个是，如果你决定使用初始化列表，总是按照它们声明的顺序罗列这些成员。这将有助于消除混淆。

## 4 对象数组

 对象数组：本质是数组。数组中的每个元素都是对象。

```cpp
[[include]] <iostream>
using namespace std;
class Acct
{
public:
    // Define default constructor and a constructor that accepts
    //  an initial balance.
    Acct() {
		balance = 0.0;
		cout  << "no param create…."  << endl;
	}
    Acct( double init_balance ) {
		balance = init_balance;
		cout << "with param create…" << endl;
	}

~Acct(){
 		cout << "delete…" << endl;
	}
private:
    double balance;
};

​​​​​​​int main()
{
		//栈中创建对象数组
		Acct myAcct[6];
  		//堆中创建对象数组
	    Acct *CheckingAcct = new Acct[3];
	    Acct *SavingsAcct = new Acct[3] {Acct(34.98), Acct(131.4), Acct(521.1)};
		delete [] CheckingAcct;
		delete [] SavingsAcct ;
}
```


## 5 静态成员 (重点)

### 5.1 静态成员变量

在 [C++](https://c.biancheng.net/cplus/) 中，我们可以使用**静态成员变量**来实现**多个对象共享数据**的目标。静态成员变量是一种特殊的成员变量，它被关键字 `static` 修饰，例如：
```cpp
class Student{
public:
    Student(char *name, int age, float score);
    void show();
public:
    static int m_total;  //静态成员变量
private:
    char *m_name;
    int m_age;
    float m_score;
};
```
这段代码声明了一个静态成员变量 m_total，用来统计学生的人数。  
  
static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为 m_total 分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象修改了 m_total，也会影响到其他对象。

**`static` 成员变量必须在类声明的外部初始化**，具体形式为：
```cpp
type class::name = value;
//type 是变量的类型，class 是类名，name 是变量名，value 是初始值。将上面的 m_total 初始化：
int Student::m_total = 0;
```
**静态成员变量在初始化时不能再加 static，但必须要有数据类型**。被 private、protected、public 修饰的静态成员变量都可以用这种方式初始化。

`static` 成员变量既可以通过**对象来访问**，也可以通过**类来访问**。

```cpp
//通过类类访问 static 成员变量
Student::m_total = 10;
//通过对象来访问 static 成员变量
Student stu("小明", 15, 92.5f);
stu.m_total = 20;
//通过对象指针来访问 static 成员变量
Student *pstu = new Student("李华", 16, 96);
pstu -> m_total = 20;
```

>[!note] 注意：**static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问**。具体来说，static 成员变量和普通的 static 变量类似，都在内存分区中的全局数据区分配内存，


````ad-col2
title: 几点说明 

1. 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。  
  
2. static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。  
  
3. 静态成员变量必须初始化，而且只能在类体外进行。例如：
```cpp
int Student::m_total = 10;
```
- 初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。  

4. 静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。
````


### 5.2 静态成员函数
在类中，static 除了可以声明[静态成员变量](https://c.biancheng.net/view/2227.html)，还可以声明静态成员函数。普通成员函数可以访问所有成员（包括成员变量和成员函数），**静态成员函数只能访问静态成员**。


```ad-col2
title: **普通成员变量与静态成员变量的区别**：
编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。

普通成员变量占用对象的内存，静态成员函数没有 this [指针](https://c.biancheng.net/c/80/)，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。  
  
普通成员函数必须通过对象才能调用，而静态成员函数没有 this 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。

静态成员函数与普通成员函数的根本区别在于：**普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）**。

```


```cpp
[[include]] <iostream>
using namespace std;

class Student{
public:
    Student(char *name, int age, float score);
    void show();
public:  //声明静态成员函数
    static int getTotal();
    static float getPoints();
private: //静态成员变量
    static int m_total;  //总人数
    static float m_points;  //总成绩
private:
    char *m_name;
    int m_age;
    float m_score;
};

int Student::m_total = 0;
float Student::m_points = 0.0;

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
    m_total++;
    m_points += score;
}
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}
//定义静态成员函数
int Student::getTotal(){
    return m_total;
}
float Student::getPoints(){
    return m_points;
}

int main(){
    (new Student("小明", 15, 90.6)) -> show();
    (new Student("李磊", 16, 80.5)) -> show();
    (new Student("张华", 16, 99.0)) -> show();
    (new Student("王康", 14, 60.8)) -> show();

    int total = Student::getTotal();
    float points = Student::getPoints();
    cout<<"当前共有"<<total<<"名学生，总成绩是"<<points<<"，平均分是"<<points/total<<endl;

    return 0;
}

```

在C++中，静态成员函数的主要目的是访问静态成员。getTotal()、getPoints() 当然也可以声明为普通成员函数，但是它们都只对静态成员进行操作，加上 static 语义更加明确。

和静态成员变量类似，静态成员函数在声明时要加 static，在定义时不能加 static。**静态成员函数可以通过类来调用**（一般都是这样做），也可以通过对象来调用，上例仅仅演示了如何通过类来调用。

### 5.3 单例模式


## 6 this 指针

this 是 [C++](https://c.biancheng.net/cplus/) 中的一个关键字，也是一个 const [指针](https://c.biancheng.net/c/80/)，它指向当前对象，通过它可以访问当前对象的所有成员。  
  
所谓当前对象，是指正在使用的对象。例如对于`stu.show();`，stu 就是当前对象，this 就指向 stu。

```cpp
[[include]] <iostream>
using namespace std;

class Student{
public:
    void setname(char *name);
    void setage(int age);
    void setscore(float score);
    void show();
private:
    char *name;
    int age;
    float score;
};

void Student::setname(char *name){
    this->name = name;
}
void Student::setage(int age){
    this->age = age;
}
void Student::setscore(float score){
    this->score = score;
}
void Student::show(){
    cout<<this->name<<"的年龄是"<<this->age<<"，成绩是"<<this->score<<endl;
}

int main(){
    Student *pstu = new Student;
    pstu -> setname("李华");
    pstu -> setage(16);
    pstu -> setscore(96.5);
    pstu -> show();

    return 0;
}
```
运行结果：
李华的年龄是16，成绩是96.5

this 只能用在类的内部，通过 this 可以访问类的所有成员，包括 private、protected、public 属性的。

![[02_C++高级语法.md_Attachments/02_C++高级语法-15.png]]

**this 的两种使用场景**：
1. 成员函数的参数和成员变量重名；
2. 普通成员函数默认有一个 this 指针指向调用该成员函数的对象;
3. this 来完成链式操作;

本例中成员函数的参数和成员变量重名，只能通过 this 区分。以成员函数`setname(char *name)`为例，它的形参是name，和成员变量name重名，如果写作name = name;这样的语句，就是给形参name赋值，而不是给成员变量name赋值。而写作this -> name = name;后，=左边的name就是成员变量，右边的name就是形参，一目了然。

>注意，this 是一个指针，要用->来访问成员变量或成员函数。

this 虽然用在类的内部，但是只有在对象被创建以后才会给 this 赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给 this 赋值。本例中，this 的值和 pstu 的值是相同的。


```ad-col2
title:this 到底是什么  
**this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this**。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。

在《C++函数编译原理和成员函数的实现》一节中讲到，成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。 这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁。
```


## 7 const成员变量和成员函数

### 7.1 const 成员变量
const 成员变量的用法和普通 const 变量的用法相似，**只需要在声明时加上 const 关键字**。**初始化 const 成员变量只有一种方法，就是通过构造函数的初始化列表**

### 7.2 const成员函数（常成员函数）
**const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值**，这种措施主要还是为了保护数据而设置的。const 成员函数也称为**常成员函数**。  
  
我们通常将 **get 函数**设置为常成员函数。读取成员变量的函数的名字通常以`get`开头，后跟成员变量的名字，所以通常将它们称为 get 函数。

常成员函数需要在声明和定义的时候在**函数头部的结尾**加上 const 关键字，请看下面的例子：
```cpp
class Student{
public:
    Student(char *name, int age, float score);
    void show();
    //声明常成员函数
    char *getname() const;
    int getage() const;
    float getscore() const;
private:
    char *m_name;
    int m_age;
    float m_score;
};

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}
//定义常成员函数
char * Student::getname() const{
    return m_name;
}
int Student::getage() const{
    return m_age;
}
float Student::getscore() const{
    return m_score;
}
```
getname()、getage()、getscore() 三个函数的功能都很简单，仅仅是为了获取成员变量的值，没有任何修改成员变量的企图，所以我们加了 const 限制，这是一种保险的做法，同时也使得语义更加明显。  
  
需要强调的是，必须在成员函数的**声明**和**定义**处**同时**加上 **const** 关键字。`char *getname() const`和`char *getname()`是两个不同的函数原型，如果只在一个地方加 const 会导致声明和定义处的函数原型冲突。

```ad-col2
title:最后区分一下 const 的位置：
- 函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如`const char * getname()`。
- 函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如`char * getname() const`。
```

Sh
## 8 const对象

在 [C++](https://c.biancheng.net/cplus/) 中，const 也可以用来修饰对象，称为**常对象**。一旦将对象定义为常对象之后，就**只能调用类的 const 成员**（包括 const 成员变量和 const 成员函数）了。

定义常对象的语法和定义常量的语法类似：
```cpp
const  class  object(params);  
class const object(params);
```

当然你也可以定义 const [指针](https://c.biancheng.net/c/80/)：
```cpp
const class *p = new class(params);  
class const *p = new class(params);
```
`class`为类名，`object`为对象名，`params`为实参列表，`p`为指针名。两种方式定义出来的对象都是常对象。

一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数），因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。

例子：
```cpp
[[include]] <iostream>
using namespace std;

class Student{
public:
    Student(char *name, int age, float score);
public:
    void show();
    char *getname() const;
    int getage() const;
    float getscore() const;
private:
    char *m_name;
    int m_age;
    float m_score;
};

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}
char * Student::getname() const{
    return m_name;
}
int Student::getage() const{
    return m_age;
}
float Student::getscore() const{
    return m_score;
}

int main(){
    const Student stu("小明", 15, 90.6);
    //stu.show();  //error
    cout<<stu.getname()<<"的年龄是"<<stu.getage()<<"，成绩是"<<stu.getscore()<<endl;

    const Student *pstu = new Student("李磊", 16, 80.5);
    //pstu -> show();  //error
    cout<<pstu->getname()<<"的年龄是"<<pstu->getage()<<"，成绩是"<<pstu->getscore()<<endl;

    return 0;
}
```


## 9 友元

### 9.1 友元的基本概述
在 [C++](https://c.biancheng.net/cplus/) 中，一个类中可以有 public、protected、private 三种属性的成员，通过对象可以访问 public 成员，只有本类中的函数可以访问本类的 private 成员。现在，介绍一种例外情况——友元（friend）。**借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员**。

- 友元的三种用法：
	- 1. 将普通函数作为类的友元；
	- 2. 将其他类的成员函数声明为友元函数；
	- 3. 将整个类声明为另一个类的友元；



### 9.2 友元函数

在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。  
  
友元函数可以访问当前类中的所有成员，包括 public、protected、private 属性的。

#### 9.2.1 普通函数（非成员函数）作为类的友元（友元函数）

```cpp
[[include]] <iostream>
using namespace std;

class Student{
public:
    Student(char *name, int age, float score);
public:
    friend void show(Student *pstu);  //将show()声明为友元函数
private:
    char *m_name;
    int m_age;
    float m_score;
};

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }

//非成员函数
void show(Student *pstu){
    cout<<pstu->m_name<<"的年龄是 "<<pstu->m_age<<"，成绩是 "<<pstu->m_score<<endl;
}

int main(){
    Student stu("小明", 15, 90.6);
    show(&stu);  //调用友元函数
    Student *pstu = new Student("李磊", 16, 80.5);
    show(pstu);  //调用友元函数

    return 0;
}
```

```
运行结果：  
小明的年龄是 15，成绩是 90.6  
李磊的年龄是 16，成绩是 80.5 
```
 
show() 是一个全局范围内的非成员函数，它不属于任何类，它的作用是输出学生的信息。m_name、m_age、m_score 是 Student 类的 private 成员，原则上不能通过对象访问，但<u>在 show() 函数中又必须使用这些 private 成员，所以将 show() 声明为 Student 类的友元函数</u>。若将上面程序中的第 8 行删去，观察编译器的报错信息。

注意，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。下面的写法是错误的：
```cpp
void show(){
    cout<<m_name<<"的年龄是 "<<m_age<<"，成绩是 "<<m_score<<endl;
}
```

成员函数在调用时会隐式地增加 this [指针](https://c.biancheng.net/c/80/)，指向调用它的对象，从而使用该对象的成员；而 show() 是非成员函数，没有 this 指针，编译器不知道使用哪个对象的成员，要想明确这一点，就必须通过参数传递对象（可以直接传递对象，也可以传递对象指针或对象引用），并在访问成员时指明对象。
![[02_C++高级语法.md_Attachments/02_C++高级语法-11.png]]

#### 9.2.2 类中的某个成员作为另一个类的友元（友元函数）
friend 函数不仅可以是全局函数（非成员函数），还可以是另外一个类的成员函数。请看下面的例子：

```cpp
[[include]] <iostream>
using namespace std;

class Address;  //提前声明Address类

//声明Student类
class Student{
public:
    Student(char *name, int age, float score);
public:
    void show(Address *addr);
private:
    char *m_name;
    int m_age;
    float m_score;
};

//声明Address类
class Address{
private:
    char *m_province;  //省份
    char *m_city;  //城市
    char *m_district;  //区（市区）
public:
    Address(char *province, char *city, char *district);
    //将Student类中的成员函数show()声明为友元函数
    friend void Student::show(Address *addr);
};

//实现Student类
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(Address *addr){
    cout<<m_name<<"的年龄是 "<<m_age<<"，成绩是 "<<m_score<<endl;
    cout<<"家庭住址："<<addr->m_province<<"省"<<addr->m_city<<"市"<<addr->m_district<<"区"<<endl;
}

//实现Address类
Address::Address(char *province, char *city, char *district){
    m_province = province;
    m_city = city;
    m_district = district;
}

int main(){
    Student stu("小明", 16, 95.5f);
    Address addr("陕西", "西安", "雁塔");
    stu.show(&addr);
   
    Student *pstu = new Student("李磊", 16, 80.5);
    Address *paddr = new Address("河北", "衡水", "桃城");
    pstu -> show(paddr);

    return 0;
}

```

```
运行结果：
小明的年龄是 16，成绩是 95.5
家庭住址：陕西省西安市雁塔区
李磊的年龄是 16，成绩是 80.5
家庭住址：河北省衡水市桃城区
```


本例定义了两个类 Student 和 Address，程序第 27 行将 Student 类的成员函数 show() 声明为 Address 类的友元函数，由此，show() 就可以访问 Address 类的 private 成员变量了。

**几点注意**：
① 程序第 4 行**对 Address 类进行了提前声明**，**是因为**在 Address 类定义之前、在 Student 类中使用到了它，如果不提前声明，编译器会报错，提示'Address' has not been declared。类的提前声明和函数的提前声明是一个道理。

② **程序将 Student 类的声明和实现分开了**，而将 Address 类的声明放在了中间，这是因为编译器从上到下编译代码，show() 函数体中用到了 Address 的成员 province、city、district，如果提前不知道 Address 的具体声明内容，就不能确定 Address 是否拥有该成员（类的声明中指明了类有哪些成员）。

> [!note] 一般情况下，类必须在正式声明之后才能使用；但是某些情况下（如上例所示），只要做好提前声明，也可以先使用。

但是应当注意，类的提前声明的使用范围是有限的，**只有在正式声明一个类以后才能用它去创建对象**。如果在上面程序的第4行之后增加如下所示的一条语句，编译器就会报错：

```
Address addr;  //企图使用不完整的类来创建对象
```

因为创建对象时要为对象分配内存，在正式声明类之前，编译器无法确定应该为对象分配多大的内存。编译器只有在“见到”类的正式声明后（其实是见到成员变量），才能确定应该为对象预留多大的内存。**在对一个类作了提前声明后，可以用该类的名字去定义指向该类型对象的指针变量（本例就定义了 Address 类的指针变量）或引用变量**，因为指针变量和引用变量本身的大小是固定的，与它所指向的数据的大小无关。

③ **一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。**

![[02_C++高级语法.md_Attachments/02_C++高级语法-13.png]]



### 9.3 整个类作为另一个类的友元（友元类）
友元类中的所有成员函数都是另外一个类的友元函数。  
  
例如将类 B 声明为类 A 的友元类，那么类 B 中的所有成员函数都是类 A 的友元函数，可以访问类 A 的所有成员，包括 public、protected、private 属性的。

```cpp
[[include]] <iostream>
using namespace std;

class Address;  //提前声明Address类

//声明Student类
class Student{
public:
    Student(char *name, int age, float score);
public:
    void show(Address *addr);
private:
    char *m_name;
    int m_age;
    float m_score;
};

//声明Address类
class Address{
public:
    Address(char *province, char *city, char *district);
public:
	/*******************友元类d的声明***********************/
    //将Student类声明为Address类的友元类
    friend class Student;
    /*******************************************************/
private:
    char *m_province;  //省份
    char *m_city;  //城市
    char *m_district;  //区（市区）
};

//实现Student类
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(Address *addr){
    cout<<m_name<<"的年龄是 "<<m_age<<"，成绩是 "<<m_score<<endl;
    cout<<"家庭住址："<<addr->m_province<<"省"<<addr->m_city<<"市"<<addr->m_district<<"区"<<endl;
}

//实现Address类
Address::Address(char *province, char *city, char *district){
    m_province = province;
    m_city = city;
    m_district = district;
}

int main(){
    Student stu("小明", 16, 95.5f);
    Address addr("陕西", "西安", "雁塔");
    stu.show(&addr);
   
    Student *pstu = new Student("李磊", 16, 80.5);
    Address *paddr = new Address("河北", "衡水", "桃城");
    pstu -> show(paddr);

    return 0;
}
```

第 24 行代码将 Student 类声明为 Address 类的友元类，声明语句为：
```
friend class Student;
```
有的编译器也可以不写 class 关键字，不过为了增强兼容性还是建议写上。  
  
关于友元，有两点需要说明：

- 友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。
- 友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。

**除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些**。

### 9.4 友元案例（遥控器的类）
> **请编写电视机类，电视机有开机和关机状态，有音量，有频道，提供音量操作的方法，频道操作的方法。由于电视机只能逐一调整频道，不能指定频道，增加遥控类，遥控类除了拥有电视机已有的功能，再增加根据输入调台功能**。提示：遥控器可作为电视机类的友元类

电视机类和遥控器类的声明
```cpp
// tv.h -- Tv and Remote classes
[[ifndef]] TV_H_
[[define]] TV_H_

class Tv
{
public:
    friend class Remote;   // Remote can access Tv private parts
    enum {Off, On};
    enum {MinVal,MaxVal = 20};
    enum {Antenna, Cable};
    enum {TV, DVD};

    Tv(int s = Off, int mc = 125) : state(s), volume(5),
        maxchannel(mc), channel(2), mode(Cable), input(TV) {}
    void onoff() {state = (state == On)? Off : On;}
    bool ison() const {return state == On;}
    bool volup();
    bool voldown();
    void chanup();
    void chandown();
    void set_mode() {mode = (mode == Antenna)? Cable : Antenna;}
    void set_input() {input = (input == TV)? DVD : TV;}
    void settings() const; // display all settings
private:
    int state;             // on or off
    int volume;            // assumed to be digitized
    int maxchannel;        // maximum number of channels
    int channel;           // current channel setting
    int mode;              // broadcast or cable
    int input;             // TV or DVD
};

class Remote
{
private:
    int mode;              // controls TV or DVD
public:
    Remote(int m = Tv::TV) : mode(m) {}
    bool volup(Tv & t) { return t.volup();}
    bool voldown(Tv & t) { return t.voldown();}
    void onoff(Tv & t) { t.onoff(); }
    void chanup(Tv & t) {t.chanup();}
    void chandown(Tv & t) {t.chandown();}
    void set_chan(Tv & t, int c) {t.channel = c;}
    void set_mode(Tv & t) {t.set_mode();}
    void set_input(Tv & t) {t.set_input();}
};
[[endif]]
```

电视机类的实现
```cpp
// tv.cpp -- methods for the Tv class (Remote methods are inline)
[[include]] <iostream>
[[include]] "tv.h"

bool Tv::volup()
{
    if (volume < MaxVal)
    {
        volume++;
        return true;
    }
    else
        return false;
}
bool Tv::voldown()
{
    if (volume > MinVal)
    {
        volume--;
        return true;
    }
    else
        return false;
}

void Tv::chanup()
{
    if (channel < maxchannel)
        channel++;
    else
        channel = 1;
}

void Tv::chandown()
{
    if (channel > 1)
        channel--;
    else
        channel = maxchannel;
}

void Tv::settings() const //const修饰成员函数
{
    using std::cout;
    using std::endl;
    cout << "TV is " << (state == Off? "Off" : "On") << endl;
    if (state == On)
    {
        cout << "Volume setting = " << volume << endl;
        cout << "Channel setting = " << channel << endl;
        cout << "Mode = "
            << (mode == Antenna? "antenna" : "cable") << endl;
        cout << "Input = "
            << (input == TV? "TV" : "DVD") << endl;
    }
}

```

主函数：
```cpp
//use_tv.cpp -- using the Tv and Remote classes
[[include]] <iostream>
[[include]] "tv.h"

int main()
{
    using std::cout;
    Tv s42;
    cout << "Initial settings for 42\" TV:\n";
    s42.settings();
    s42.onoff();
    s42.chanup();
    cout << "\nAdjusted settings for 42\" TV:\n";
    s42.settings();

    Remote grey;

    grey.set_chan(s42, 10);
    grey.volup(s42);
    grey.volup(s42);
    cout << "\n42\" settings after using remote:\n";
    s42.settings();

    Tv s58(Tv::On);
    s58.set_mode();
    grey.set_chan(s58,28);
    cout << "\n58\" settings:\n";
    s58.settings();
    // std::cin.get();
    return 0; 
}

```

运行结果：
```
Initial settings for 42" TV:
TV is Off

Adjusted settings for 42" TV:
TV is On
Volume setting = 5
Channel setting = 3
Mode = cable
Input = TV

42" settings after using remote:
TV is On
Volume setting = 7
Channel setting = 10
Mode = cable
Input = TV

58" settings:
TV is On
Volume setting = 5
Channel setting = 28
Mode = antenna
Input = TV
```





## 10 class和struct到底有什么区别

C++ 中保留了 C 语言的 struct 关键字，并且加以扩充。在 C 语言中，struct 只能包含成员变量，不能包含成员函数。而在 C++中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。

>[!note] C++中的 struct 和 class 基本是通用的，唯有几个细节不同：
> - 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
> - class 继承默认是 private 继承，而 struct 继承默认是 public 继承。
> - class 可以使用模板，而 struct 不能。

C++ 没有抛弃C语言中的 struct 关键字，其意义就在于给C语言程序开发人员有一个归属感，并且能让C++编译器兼容以前用C语言开发出来的项目。

**在编写C++代码时，我强烈建议使用 class 来定义类，而使用 struct 来定义结构体，这样做语义更加明确。**

## 11 string详解

### 11.1 基础概要
[C++](https://c.biancheng.net/cplus/) 大大增强了对字符串的支持，除了可以使用 C 风格的字符串，还可以使用内置的 string 类。string 类处理起字符串来会方便很多，完全可以代替 C 语言中的字符数组或字符串[指针](https://c.biancheng.net/c/80/)。  
  
string 是 C++ 中常用的一个类，它非常重要。  
  
使用 string 类需要包含头文件 `<string>`，下面的例子介绍了几种定义 string 变量（对象）的方法：
```cpp
[[include]] <iostream>
[[include]] <string>
using namespace std;

int main(){
    string s1;
    string s2 = "c plus plus";
    string s3 = s2;
    string s4 (5, 's');
    return 0;
}
```
变量 s1 只是定义但没有初始化，编译器会将默认值赋给 s1，默认值是`""`，也即空字符串。  
  
变量 s2 在定义的同时被初始化为`"c plus plus"`。与C风格的字符串不同，string 的结尾没有结束标志`'\0'`。  
  
变量 s3 在定义的时候直接用 s2 进行初始化，因此 s3 的内容也是`"c plus plus"`。  
  
变量 s4 被初始化为由 5 个`'s'`字符组成的字符串，也就是`"sssss"`。  
  
从上面的代码可以看出，string 变量可以直接通过赋值操作符 ` = ` 进行赋值。string 变量也可以用 C 风格的字符串进行赋值，例如，s2 是用一个字符串常量进行初始化的，而 s3 则是通过 s2 变量进行初始化的。  
  
与C风格的字符串不同，当我们需要知道字符串长度时，可以调用 string 类提供的 length() 函数。如下所示：
```cpp
string s = "http://c.biancheng.net";
int len = s.length();
cout<<len<<endl;
```
输出结果为`22`。由于 string 的末尾没有`'\0'`字符，所以 **length() 返回的是字符串的真实长度**，而不是长度 +1。

### 11.2 string 字符串的输入输出

string 类重载了输入输出运算符，可以像对待普通变量那样对待 string 变量，也就是用 `>>` 进行输入，用 `<<` 进行输出。请看下面的代码：  
```cpp
[[include]] <iostream>
[[include]] <string>

using namespace std;

int main(){
    string s;
    cin>>s;  //输入字符串
    cout<<s<<endl;  //输出字符串
    return 0;
}
```
运行结果：  
```
http://c.biancheng.net  http://vip.biancheng.net↙  
http://c.biancheng.net  
```

虽然我们输入了两个由空格隔开的网址，但是只输出了一个，这是因为输入运算符`>>`默认会忽略空格，遇到空格就认为输入结束，所以最后输入的`http://vip.biancheng.net`没有被存储到变量 s。

### 11.3 访问字符串中的字符

string 字符串也可以像C风格的字符串一样按照下标来访问其中的每一个字符。string 字符串的**起始下标**仍是**从 0 开始**。请看下面的代码：

```cpp
[[include]] <iostream>
[[include]] <string>
using namespace std;

int main(){
    string s = "1234567890";
    for(int i=0,len=s.length(); i<len; i++){
        cout<<s[i]<<" ";
    }
    cout<<endl;
    s[5] = '5';
    cout<<s<<endl;
    return 0;
}
```
运行结果：  
```
1 2 3 4 5 6 7 8 9 0  
1234557890  
```

本例定义了一个 string 变量 s，并赋值 "1234567890"，之后用 for 循环遍历输出每一个字符。借助下标，除了能够访问每个字符，也可以修改每个字符，`s[5] = '5';`就将第6个字符修改为 '5'，所以 s 最后为 "1234557890"。

### 11.4 字符串的拼接

有了 string 类，我们可以使用`+`或`+=`运算符来直接拼接字符串，非常方便，再也不需要使用C语言中的 strcat()、strcpy()、malloc() 等函数来拼接字符串了，再也不用担心空间不够会溢出了。  
  
用`+`来拼接字符串时，运算符的两边可以都是 string 字符串，也可以是一个 string 字符串和一个C风格的字符串，还可以是一个 string 字符串和一个字符数组，或者是一个 string 字符串和一个单独的字符。请看下面的例子：
```cpp
[[include]] <iostream>
[[include]] <string>
using namespace std;

int main(){
    string s1 = "first ";
    string s2 = "second ";
    char *s3 = "third ";
    char s4[] = "fourth ";
    char ch = '@';

    string s5 = s1 + s2;
    string s6 = s1 + s3;
    string s7 = s1 + s4;
    string s8 = s1 + ch;

    cout<<s5<<endl<<s6<<endl<<s7<<endl<<s8<<endl;

    return 0;
}
```
运行结果：  
```
first second  
first third  
first fourth  
first @
```

### 11.5 string 字符串的增删改查

这个表格总结了 C++中字符串的常见操作，包括创建、访问、修改和查询字符串的方法。

| 操作             | 描述                                                                               | 示例代码                                                               |
| ---------------- | ---------------------------------------------------------------------------------- | ---------------------------------------------------------------------- |
| 创建字符串       | 使用`std==string`构造函数创建字符串                                                | `std==string str = "hello";`                                           |
| 获取字符串长度   | 使用`size()`或`length()`获取字符串长度                                             | `int length = str.length();`                                           |
| 设置字符串长度   | 使用`resize()`设置字符串长度                                                       | `str.resize(10);`                                                      |
| 添加字符         | 使用 ` += ` 运算符在字符串末尾添加字符                                             | `str += "world";`                                                      |
| 插入字符         | 使用`std::insert()`在指定位置插入字符                                              | `str.insert(5, "world");`                                              |
| 删除字符         | 使用`erase()`删除字符串中的字符                                                    | `str.erase(0, 5);`                                                     |
| 替换字符         | 使用`std::replace()`替换字符串中的字符                                             | `str.replace(0, 5, "world");`                                          |
| 查找子字符串     | 使用`find()`查找子字符串在字符串中首次出现的位置                                   | `size_t position = str.find("world");`                                 |
| 查找字符         | 使用`find()`查找指定字符在字符串中首次出现的位置                                   | `size_t position = str.find('l');`                                     |
| 子字符串替换     | 使用`std::replace()`替换字符串中子字符串                                           | `str.replace(0, 5, "hello");`                                          |
| 字符替换         | 使用`std::replace()`替换字符串中指定位置的字符                                     | `str.replace(7, 1, "W");`                                              |
| 获取子字符串     | 使用`substr()`获取字符串的一部分                                                   | `std::string sub_str = str.substr(0, 5);`                              |
| 访问字符         | 使用`[]`运算符访问字符串中的字符                                                   | `char ch = str[7];`                                                    |
| 字符串拼接       | 使用`+`运算符拼接字符串                                                            | `std::string str2 = "C++"; str += str2;`                               |
| 字符串比较       | 使用 `\==`、` != `、` < `、`>`、`<=`、` >= ` 比较字符串                            | `bool is_equal = str == "hello";`                                      |
| 字符串转换       | 使用`std==to_string()`将字符串转换为数字                                           | `int num = std==stoi(str);`                                            |
| 数字转换字符串   | 使用`std==string`将数字转换为字符串                                                | `std==string str_num = std::to_string(42);`                            |
| 字符串大小写转换 | 使用`std==tolower()`将字符串转换为小写                                             | `std==string lower_str = std::tolower(str);`                           |
| 字符串查找       | 使用 `std==find()` 查找指定字符串在另一个字符串中是否存在,从第二个参数开始往后查找 | `bool found = std==find(str2.begin(), str2.end(), 'h') != str2.end();` |
| 字符串查找       | 使用 `std::rfind()` 查找指定字符串在另一个字符串中是否存在,最多查找到第二个参数处  | `int index = std.rfind(s2,6);`                                         |
| 字符串查找                 | 使用`find_first_of()`函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置                                                                                   | `int index = std.find_first_of(s2)`    |

rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回 string:: npos。

find_first_of() 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置.


#### 11.5.1 字符串的增


#### 11.5.2 字符串的删


#### 11.5.3 字符串的改


#### 11.5.4 字符串的查
















