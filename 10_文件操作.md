---
UID: 2401021022
link: ""
cssclasses: 
tags:
  - C加/文件操作
---
## 1 C++文件类及用法

 C++ 标准库中专门提供了 3 个类用于实现文件操作，它们统称为文件流类，这 3 个类分别为：
- ifstream：专用于从文件中读取数据；
- ofstream：专用于向文件中写入数据；
- fstream：既可用于从文件中读取数据，又可用于向文件中写入数据。

>这 3 个文件流类都位于 `<fstream>` 头文件中，因此在使用它们之前，程序中应先引入此头文件。

![[10_文件操作.md_Attachments/10_文件操作.png]]

>值得一提的是，和 `<iostream>` 头文件中定义有 ostream 和 istream 类的对象 cin 和 cout 不同， `<fstream>`头文件中并没有定义可直接使用的 fstream、 ifstream 和 ofstream 类对象。因此，如果我们想使用该类操作文件，需要自己创建相应类的对象。

> 值得一提的是，无论是读取文件中的数据，还是向文件中写入数据，最先要做的就是调用 `open()` 成员方法打开文件。同时在操作文件结束后，还必须要调用 `close()` 成员方法关闭文件。


## 2 open 和 close()打开/关闭文件方法详解

### 2.1 open打开文件方法
在对文件进行读写操作之前，先要打开文件。打开文件有以下**两个目的**：
- 通过指定文件名，建立起文件和文件流对象的关联，以后要对文件进行操作时，就可以通过与之关联的流对象来进行。
- 指明文件的使用方式。使用方式有只读、只写、既读又写、在文件末尾添加数据、以文本方式使用、以二进制方式使用等多种。

打开文件可以通过以下**两种方式**进行：
- 调用**流对象的 open 成员函数**打开文件。
- 定义文件流对象时，通过**构造函数**打开文件。

### 2.2 close 打开文件方法

调用 open() 方法打开文件，是文件流对象和文件之间建立关联的过程。那么，调用 close() 方法关闭已打开的文件，就可以理解为是切断文件流对象和文件之间的关联。注意， close() 方法的功能仅是切断文件流与文件之间的关联，该文件流并不会被销毁，其后续还可用于关联其它的文件。

在某些情况下（例如上面程序中），即便不显式调用 close() 方法，文件的读写操作也能成功执行。因为当文件流对象的生命周期结束时，会自行调用析构函数，此函数内部会先调用 close() 方法切断文件流对象与任何文件的关联，最后才销毁它。

在实际进行文件操作的过程中，对于打开的文件，**要及时调用 close() 方法将其关闭**，否则很可能会导致读写文件失败。

在很多实际场景中，即便已经对文件执行了写操作，但后续还可能会执行其他的写操作。对于这种情况，我们可能并不想频繁地打开/关闭文件，可以使用 `flush()` 方法及时刷新输出流缓冲区，也能起到防止写入文件失败的作用。

**总之， C++ 中使用 open() 打开的文件，在读写操作执行完毕后，应及时调用 close() 方法关闭文件，或者对文件执行写操作后及时调用 flush() 方法刷新输出流缓冲区。**

### 2.3 文本和二进制打开文件方式的区别

>文本方式和二进制方式并没有本质上的区别，只是对于换行符的处理不同。

```
在 UNIX/Linux 平台中，用文本方式或二进制方式打开文件没有任何区别，因为文本文件以 \n（ ASCII 码为0x0a）作为换行符号。

但在 Windows 平台上，文本文件以连在一起的 \r\n 作为换行符号。如果以文本方式打开文件，当读取文件时，
程序会将文件中所有的 \r\n 转换成一个字符 \n。也就是说，如果文本文件中有连续的两个字符是 \r\n，则程序会丢弃前面的 \r，只读入 \n。
同样当写入文件时，程序会将 \n 转换成 \r\n 写入。也就是说，如果要写入的内容中有字符 \n，则在写入该字符前，程序会自动先写入一个 \r。
因此在 Windows 平台上，如果用文本方式打开二进制文件进行读写，读写的内容就可能和文件的内容有出入。
```

>总的来说， Linux 平台使用哪种打开方式都行； Windows 平台上最好用 `"ios:: in | ios:: out"` 等打开文本文件，用 `"ios:: binary"` 打开二进制文件。但无论哪种平台，用二进制方式打开文件总是最保险的。


## 3 文本文件读写操作详解

- 对文件的读/写操作又可以细分为 2 类：
	- 文本形式读写文件
	- 二进制形式读写文件。

C++ 标准库中，提供了 2 套读写文件的方法组合，分别是：
1. 使用 `>>` 和 `<<` 读写文件：适用于以文本形式读写文件；
2. 使用 `read() ` 和 `write()` 成员方法读写文件：适用于以二进制形式读写文件


### 3.1 使用 `>>` 和 `<<` 读写文本形式文件
1. fstream 或者 ifstream 类负责实现对文件的读取，它们内部都对 >> 输出流运算符做了重载；同样， fstream 和 ofstream 类负责实现对文件的写入，它们的内部也都对 <<输出流运算符做了重载。
2. 当 fstream 或者 ifstream 类对象打开文件（通常以 ios:: in 作为打开模式）之后，就可以直接借助 >>输入流运算符，读取文件中存储的字符（或字符串）；当 fstream 或者 ofstream 类对象打开文件（通常以ios::out 作为打开模式）后，可以直接借助 << 输出流运算符向文件中写入字符（或字符串）。



### 3.2 使用 `read() ` 和 `write()` 成员方法读写二进制形式文件

#### 3.2.1 ostream::write()方法写文件

ofstream 和 fstream 的 write() 成员方法实际上继承自 ostream 类，其功能是将内存中 buffer 指向的 count 个字节的内容写入文件。

基本格式如下：
```cpp
ostream & write(char* buffer, int count);
```

其中， buffer 用于指定要写入文件的二进制数据的起始位置； count 用于指定写入字节的个数

> 也就是说，该方法可以被 ostream 类的 cout 对象调用，常用于向屏幕上输出字符串。同时，它还可以被 ofstream 或者 fstream 对象调用，用于将指定个数的二进制数据写入文件。

同时，**该方法会返回一个作用于该函数的引用形式的对象**。举个例子，obj.write() 方法的返回值就是对 obj 对象的引用。  
  
需要注意的一点是，write() 成员方法向文件中写入若干字节，可是调用 write() 函数时并没有指定这些字节写入文件中的具体位置。事实上，write() 方法会从文件写指针指向的位置将二进制数据写入。所谓文件写指针，是是 ofstream 或 fstream 对象内部维护的一个变量，文件刚打开时，文件写指针指向的是文件的开头（如果以 ios::app 方式打开，则指向文件末尾），用 write() 方法写入 n 个字节，写指针指向的位置就向后移动 n 个字节。


#### 3.2.2 istream::read()方法读文件

ifstream 和 fstream 的 read() 方法实际上继承自 istream 类，其功能正好和 write() 方法相反，即从文件中读取 count 个字节的数据。该方法的语法格式如下：
```cpp
istream & read(char* buffer, int count);
```

其中，buffer 用于指定读取字节的起始位置，count 指定读取字节的个数。同样，该方法也会返回一个调用该方法的对象的引用。

和 write() 方法类似，read() 方法从文件读指针指向的位置开始读取若干字节。所谓文件读指针，可以理解为是 ifstream 或 fstream 对象内部维护的一个变量。文件刚打开时，文件读指针指向文件的开头（如果以 ios:: app 方式打开，则指向文件末尾），用 read() 方法读取 n 个字节，读指针指向的位置就向后移动 n 个字节。因此，打开一个文件后连续调用 read() 方法，就能将整个文件的内容读取出来。


### 3.3 C++ get()和put()读写文件详解

在某些特殊的场景中，我们可能需要逐个读取文件中存储的字符，或者逐个将字符存储到文件中。这种情况下，就可以调用 get() 和 put() 成员方法实现。

#### 3.3.1 ostream::put()成员方法

当 fstream 和 ofstream 文件流对象调用 put() 方法时，该方法的功能就变成了**向指定文件中写入单个字符**。put() 方法的语法格式如下：
```cpp
ostream& put (char c);
```

其中，c 用于指定要写入文件的字符。该方法会返回一个调用该方法的对象的引用形式。例如，`obj.put()` 方法会返回 obj 这个对象的引用。

>注意，由于文件存放在硬盘中，硬盘的访问速度远远低于内存。如果每次写一个字节都要访问硬盘，那么文件的读写速度就会慢得不可忍受。<u>因此，操作系统在接收到 put() 方法写文件的请求时，会先将指定字符存储在一块指定的内存空间中（称为文件流输出缓冲区），等刷新该缓冲区（缓冲区满、关闭文件、手动调用 flush() 方法等，都会导致缓冲区刷新）时，才会将缓冲区中存储的所有字符“一股脑儿”全写入文件。</u>



#### 3.3.2 istream::get()成员方法

和 put() 成员方法的功能相对的是 get() 方法，其定义在 istream 类中，借助 cin.get() 可以读取用户输入的字符。在此基础上，fstream 和 ifstream 类继承自 istream 类，因此 fstream 和 ifstream 类的对象也能调用 get() 方法。  
  
当 fstream 和 ifstream 文件流对象调用 get() 方法时，其功能就变成了从指定文件中读取单个字符（还可以读取指定长度的字符串）。值得一提的是，get() 方法的语法格式有很多，这里仅介绍最常用的 2 种：  
```cpp
int get();  
istream& get (char& c);
```

其中，第一种语法格式的返回值就是读取到的字符，只不过返回的是它的 ASCII 码，如果碰到输入的末尾，则返回值为 EOF。第二种语法格式需要传递一个字符变量，get() 方法会自行将读取到的字符赋值给这个变量。

本节前面在讲解 put() 方法时，生成了一个 out.txt 文件，下面的样例演示了如何通过 get() 方法逐个读取 out.txt 文件中的字符：  

```cpp
[[include]] <iostream>
[[include]] <fstream>
using namespace std;

int main()
{
    char c;
    //以二进制形式打开文件
    ifstream inFile("out.txt", ios==out | ios==binary);

    if (!inFile) {
        cout << "error" << endl;
        return 0;
    }
    while ( (c=inFile.get())&&c!=EOF )   //或者 while(inFile.get(c))，对应第二种语法格式
    {
        cout << c ;
    }
    inFile.close();
    return 0;
}

```

程序执行结果为：
```
http://c.biancheng.net/cplus/
```

注意，和 put() 方法一样，操作系统在接收到 get() 方法的请求后，哪怕只读取一个字符，也会一次性从文件中将很多数据（通常至少是 512 个字节，因为硬盘的一个扇区是 512 B）读到一块内存空间中（可称为文件流输入缓冲区），这样当读取下一个字符时，就不需要再访问硬盘中的文件，直接从该缓冲区中读取即可。


### 3.4 getline()：从文件中读取一行字符串

`getline()`方法定义在 istream 类中，而 fstream 和 ifstream 类继承自 istream 类，因此 fstream 和 ifstream 的类对象可以调用getline() 成员方法。  
  
当文件流对象调用 getline() 方法时，该方法的功能就变成了从指定文件中读取一行字符串。该方法有以下 2 种语法格式：
```cpp
istream & getline(char* buf, int bufSize);  
istream & getline(char* buf, int bufSize, char delim);
```

其中，第一种语法格式用于从文件输入流缓冲区中读取 bufSize-1 个字符到 buf，或遇到 \n 为止（哪个条件先满足就按哪个执行），该方法会自动在 buf 中读入数据的结尾添加 '\0'。  
  
第二种语法格式和第一种的区别在于，第一个版本是读到 \n 为止，第二个版本是读到 delim 字符为止。\n 或 delim 都不会被读入 buf，但会被从文件输入流缓冲区中取走。  
  
以上 2 种格式中，**getline() 方法都会返回一个当前所作用对象的引用**。比如，**obj.getline()** 会返回 obj 的引用。  

> 注意，如果文件输入流中`\n` 或 `delim` 之前的字符个数达到或超过 bufSize，就会导致读取失败。

### 3.5 移动和获取文件读写指针（seekp、seekg、tellg、tellp）

在读写文件时，有时希望直接跳到文件中的某处开始读写，这就需要先将文件的读写指针指向该处，然后再进行读写。
- ifstream 类和 fstream 类有 seekg 成员函数，可以设置文件读指针的位置；
- ofstream 类和 fstream 类有 seekp 成员函数，可以设置文件写指针的位置。

所谓“位置”，就是指距离文件开头有多少个字节。文件开头的位置是 0。

这两个函数的原型如下：
```cpp
ostream & seekp (int offset, int mode);
istream & seekg (int offset, int mode);
```

mode 代表文件读写指针的设置模式，有以下三种选项：
`ios::beg`：让文件读指针（或写指针）指向从文件开始向后的 offset 字节处。offset 等于 0 即代表文件开头。在此情况下，offset 只能是非负数。
`ios::cur`：在此情况下，offset 为负数则表示将读指针（或写指针）从当前位置朝文件开头方向移动 offset 字节，为正数则表示将读指针（或写指针）从当前位置朝文件尾部移动 offset字节，为 0 则不移动。
`ios::end`：让文件读指针（或写指针）指向从文件结尾往前的 |offset|（offset 的绝对值）字节处。在此情况下，offset 只能是 0 或者负数。

此外，我们还可以得到当前读写指针的具体位置：
- ifstream 类和 fstream 类还有 tellg 成员函数，能够返回文件读指针的位置；
- ofstream 类和 fstream 类还有 tellp 成员函数，能够返回文件写指针的位置。

这两个成员函数的原型如下：
```cpp
int tellg();
int tellp();
```

要获取文件长度，可以用 seekg 函数将文件读指针定位到文件尾部，再用 tellg 函数获取文件读指针的位置，此位置即为文件长度。


## 4 测试

例题：假设学生记录文件 students.dat 是按照姓名排好序的，编写程序，在 students.dat 文件中用折半查找的方法找到姓名为 Jack 的学生记录，并将其年龄改为 20（假设文件很大，无法全部读入内存）


```cpp
[[include]] <iostream>
[[include]] <fstream>
[[include]] <cstring>
using namespace std;
class CStudent
{
    public:
        char szName[20];
        int age;
};
int main()
{
    CStudent s;       
    fstream ioFile("students.dat", ios==in|ios==out);//用既读又写的方式打开
    if(!ioFile) {
        cout << "error" ;
        return 0;
    }
    ioFile.seekg(0,ios::end); //定位读指针到文件尾部，
                              //以便用以后tellg 获取文件长度
    int L = 0,R; // L是折半查找范围内第一个记录的序号
                  // R是折半查找范围内最后一个记录的序号
    R = ioFile.tellg() / sizeof(CStudent) - 1;
    //首次查找范围的最后一个记录的序号就是: 记录总数1
    do {
        int mid = (L + R)/2; //要用查找范围正中的记录和待查找的名字比对
        ioFile.seekg(mid *sizeof(CStudent),ios::beg); //定位到正中的记录
        ioFile.read((char *)&s, sizeof(s));
        int tmp = strcmp( s.szName,"Jack");
        if(tmp == 0) { //找到了
            s.age = 20;
            ioFile.seekp(mid*sizeof(CStudent),ios::beg);
            ioFile.write((char*)&s, sizeof(s));
            break;
        }
        else if (tmp > 0) //继续到前一半查找
            R = mid - 1 ;
        else  //继续到后一半查找
            L = mid + 1;
    }while(L <= R);
    ioFile.close();
    return 0;
}
```














